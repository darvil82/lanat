package lanat.parsing.errors;

import lanat.Command;
import lanat.parsing.Token;
import lanat.parsing.TokenType;
import org.jetbrains.annotations.NotNull;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;

/**
 * Handles all errors generated by the parser and tokenizer.
 */
public class ErrorHandler {
	/** The list of tokens that were parsed. */
	public final @NotNull List<@NotNull Token> tokens;
	/** The root command. */
	private final @NotNull Command rootCmd;
	/** The index of the last command encountered in the token list. */
	private int absoluteCmdTokenIndex = -1;


	/**
	 * Creates a new error handler for the specified command.
	 * @param rootCommand The root command.
	 */
	public ErrorHandler(@NotNull Command rootCommand) {
		this.rootCmd = rootCommand;
		this.tokens = Collections.unmodifiableList(rootCommand.getFullTokenList());
	}

	/**
	 * Handles all errors and returns a list of error messages generated.
	 */
	public @NotNull List<@NotNull String> handleErrors() {
		final List<Command> commands = this.rootCmd.getTokenizer().getTokenizedCommands();
		final ArrayList<String> errors = new ArrayList<>();

		for (int i = 0; i < commands.size(); i++) {
			final Command cmd = commands.get(i);
			this.absoluteCmdTokenIndex = this.getCommandTokenIndexByNestingLevel(i);

			// gather all errors
			new ArrayList<ParseStateErrorBase<?>>() {{
				this.addAll(cmd.getErrorsUnderDisplayLevel());
				this.addAll(cmd.getTokenizer().getErrorsUnderDisplayLevel());
				this.addAll(cmd.getParser().getCustomErrors());
				this.addAll(cmd.getParser().getErrorsUnderDisplayLevel());
			}}.stream()
				.sorted(Comparator.comparingInt(x -> x.tokenIndex)) // sort them by their token index...
				.forEach(e -> errors.add(e.handle(this))); // ...and handle them
		}

		return Collections.unmodifiableList(errors);
	}

	/**
	 * Returns the token at the specified index, offset by the current command's token index
	 * ({@link #absoluteCmdTokenIndex}).
	 */
	public @NotNull Token getRelativeToken(int index) {
		return this.tokens.get(this.absoluteCmdTokenIndex + index);
	}

	/**
	 * Returns the index of a command in the token list by its nesting level by order of appearance. For example, in a
	 * token list like this:<br>
	 * <pre>{@code
	 * {
	 *   COMMAND,
	 *   ARGUMENT_NAME,
	 *   ARGUMENT_VALUE,
	 *   COMMAND, // <- here
	 *   ARGUMENT_NAME_LIST,
	 *   COMMAND,
	 *   ARGUMENT_NAME
	 * }}</pre>
	 * The nesting level of the second Sub-Command is <strong>1</strong> (starting at 0), and its index in the token
	 * list is <strong>3</strong>.
	 *
	 * @return <code>-1</code> if the command is not found.
	 */
	private int getCommandTokenIndexByNestingLevel(int level) {
		if (level <= 0) return 0;

		for (int i = 0, appearances = 0; i < this.tokens.size(); i++) {
			if (this.tokens.get(i).type() == TokenType.COMMAND) {
				appearances++;
			}
			if (appearances > level) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Returns the root command that this error handler is handling errors for.
	 * @return The root command that this error handler is handling errors for.
	 */
	public @NotNull Command getRootCommand() {
		return this.rootCmd;
	}

	/**
	 * Returns the index of the current command in the token list.
	 * @return The index of the current command in the token list.
	 */
	public int getAbsoluteCmdTokenIndex() {
		return this.absoluteCmdTokenIndex;
	}
}